# -*- coding: utf-8 -*-
# File tests/dot/test_dot.py
"""Tests for dot package."""
import random
import sys


import pytest
import numpy as np

sys.path.insert(0,'.')

from dot import *

IMPLS = (
    dot     # the initial Python implementation
  , jit_dot # numba.jit(dot)
  , cpp_dot # the C++ implementation
  , f90_dot # the Modern Fortran implementation
  , np.dot  # the Numpy implementation
)
IMPL_NAMES = {
    dot    : 'python dot version',
    jit_dot: 'numba.jit()dot version',
    cpp_dot: 'C++ dot version',
    f90_dot: 'f90 dot version',
    npy_dot: 'numpy.dot version',
}
# Print the names of the implementations for ease of reference.
# In case of failure, the value of dot_impl will be reported, but, although unique,
# it is not extremely informative.
print("\nList of implementations types")
for dot_impl, name in IMPL_NAMES.items():
    print(f'{dot_impl=} = {name}')
print()

N_TEST_REPETITIONS = 1000
N_TIME_REPETITIONS = 10

def test_dot_commutative():
    """The test driver for commutativity of dot product implementations"""
    def assert_dot_commutative(dot_impl, a, b):
        """The test itself"""
        ab = dot_impl(a, b)
        ba = dot_impl(b, a)
        assert ab == ba

    _test(assert_dot_commutative, _array_pair_generator(2, extra_types=EXTRA_ARRAY_TYPES))

def test_time_dot():
    """"""
    _time(IMPLS, array_pair_generator=_time_array_pair_generator)

################################################################################
# Helper functions
################################################################################
def _time(impls, array_pair_generator, *array_pair_generator_args, **array_pair_generator_kwargs):
    """Time the functions in `impls` for pairs of arrays provided by
    `array_pair_generator(*array_pair_generator_args, **array_pair_generator_kwargs)`

    Args:
        impls: sequence of implementations to time
        array_pair_generator: a generator function that generates pairs of arrays serving as arguments to `impls`
        *array_pair_generator_args: list of position arguments to `array_pair_generator`
        **array_pair_generator_kwargs: list of keyword arguments to `array_pair_generator`

    Because the `array_pair_generator` must be reused for every implementation in `impls`,
    we must be able to restart it. Hence, we pass the method and its arguments separately.
    """
    for impl in impls:
        for a, b in array_pair_generator(*array_pair_generator_args, **array_pair_generator_kwargs):
            print(f'{impl=}: ({IMPL_NAMES[impl]}) {type(a)=} {type(b)=} size={len(a):5g}: ', end='')
            time_dot_impl = _time_fun(impl)
            time_dot_impl(a, b)

from time import perf_counter
def _time_fun(dot_impl):
    """A decorator that times the decorated function."""

    def wrapper(a,b):
        N = N_TIME_REPETITIONS
        t0 = perf_counter()
        for _ in range(N):
            dot_impl(a,b)
        t = (perf_counter() - t0) / N
        print(f'{t:>10.3}s')

    return wrapper

def run_impls(test, a, b):
    """Apply the test `test` to all dot implementations with argument arrays `a` and `b`."""
    for dot_impl in IMPLS:
        # cpp_dot cannot handle lists. If either array is a list we skip the test
        if dot_impl is cpp_dot \
        and (isinstance(a, list) or isinstance(b, list)):
            continue
        # An informative message to help during debugging
        msg = f'{dot_impl=} (={IMPL_NAMES[dot_impl]}), {type(a)=}, {type(b)=}'
        print(msg)
        test(dot_impl, a, b)

def _test(test, array_pair_generator):
    """Apply the test `test` to all array pairs generated by the generator function
    `array_pair_generator`."""
    for a, b in array_pair_generator:
        run_impls(test, a, b)

def _array_pair_generator(
      n: int = 1
    , same_length : bool = True
    , min_length : int = 1
    , max_length : int = 20
    , extra_types: list = []
):
    """Generator function for generating pairs of arrays with random values.

    Args:
        n: number of pairs to be generated
        same_length: if True, the arrays in a pair have the same length
        min_length: minimum length of the arrays
        max_length: maximum length of the arrays
    """
    j = -1
    for i in range(n):
        # generate two random numpy arrays
        m = random.randint(min_length, max_length)
        a = np.random.random(m)
        if same_length:
            b = np.random.random(m)
        else:
            m2 = random.randint(min_length, max_length)
            # if m2 happens to be equal to m generate new m2:
            while m2 == m:
                m2 = random.randint(min_length, max_length)
            b = np.random.random(m2)

        for at,bt in _array_pair_type_generator(a, b, extra_types=extra_types):
            yield (at, bt)


def _time_array_pair_generator(
      min_length : int = 100
    , length_factor: int = 100
    , max_length : int = 1_000_000
    , extra_types : list = []
):
    """Generator function for generating pairs of arrays with random values for timings. Arrays will
    grow in length from `min_length` to `max_length` by a factor `length_factor`.

    Args:
        only_numpy_arrays: if True, all arrays are Numpy arrays. Otherwise, Numpy arrays or Python lists.
        min_length: minimum length of the arrays
        length_factor: increase the array length by this factor each time
        max_length: maximum length of the arrays
    """
    j = 0
    m = min_length
    while m <= max_length:
        a = np.random.random(m)
        b = np.random.random(m)

        for at,bt in _array_pair_type_generator(a, b, extra_types=extra_types):
            yield (at, bt)

        m *= length_factor

def _array_pair_type_generator(a: np.ndarray, b: np.ndarray, types = (np.ndarray, list)):
    """Generator function for generating all possible array type combinations for `a` and `b`.

    E.g. `_array_pair_type_generator(a, b, (list))` will generate `(a,b)`, `(a,list(b))`, `(list(a),b)`
    and `(list(a),list(b))`, in that order. If `extra_types` is empty, it will generate only `(a,b)`
    """
    types = (np.ndarray, list)
    n = len(types)
    for i in range(n):
        # if i == 0 a is already a np.ndarray
        aa = a if i == 0 else types[i](a)
        for j in range(n):
            # if j == 0 b is already a np.ndarray
            bb = b if j == 0 else types[j](b)
            yield (aa, bb)

def test_array_pair_type_generator():
    a = np.random.random(4)
    b = np.random.random(4)
    for a,b in _array_pair_type_generator(a,b):
        print(f'{type(a)=} {type(b)=} ')
    for a,b in _array_pair_type_generator(a,b, [list]):
        print(f'{type(a)=} {type(b)=} ')

# ==============================================================================
if __name__ == "__main__":
    the_test_you_want_to_debug = test_time_dot
    print("__main__ running", the_test_you_want_to_debug)
    the_test_you_want_to_debug()
    print('-*# finished #*-')
